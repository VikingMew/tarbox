# Tarbox 架构概述

## 项目定位

Tarbox 是一个基于 PostgreSQL 的分布式文件系统，专为 AI Agent 和云原生环境设计。通过将关系型数据库作为存储后端，提供可靠、可审计、可分层的文件存储解决方案。

## 核心设计理念

### 1. 数据库作为存储后端

传统文件系统直接操作磁盘块，而 Tarbox 选择将 PostgreSQL 作为存储层，带来以下优势：

- **ACID 保证**：利用数据库事务保证文件操作的原子性和一致性
- **高可用性**：借助 PostgreSQL 的复制和故障转移机制
- **易于管理**：使用 SQL 进行数据管理和查询
- **内置备份**：利用数据库的备份恢复能力
- **跨平台**：不依赖特定操作系统的文件系统实现

### 2. 分层设计原则

系统采用清晰的分层架构：

```
应用层（Agent/用户应用）
    ↓
接口层（FUSE/POSIX）
    ↓
文件系统层（VFS抽象）
    ↓
存储层（PostgreSQL）
```

每层职责明确，层间通过定义良好的接口通信。

### 3. 为 Agent 优化

针对 AI Agent 的特殊需求：

- **完整审计**：记录所有文件操作，便于 Agent 行为分析
- **版本管理**：支持文件版本历史，便于回溯和调试
- **访问模式分析**：基于访问模式优化存储策略
- **多租户隔离**：为不同 Agent 提供隔离的命名空间

## 系统架构

### 整体架构图

```
┌────────────────────────────────────────────────────────┐
│                    应用层                               │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│  │ AI Agent │  │   Pod    │  │  Client  │            │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘            │
└───────┼────────────┼─────────────┼───────────────────┘
        │            │              │
┌───────┼────────────┼──────────────┼───────────────────┐
│       │     POSIX接口层           │                    │
│  ┌────▼─────────────▼─────────────▼────┐              │
│  │         FUSE Interface               │              │
│  └────────────────┬─────────────────────┘              │
└───────────────────┼────────────────────────────────────┘
                    │
┌───────────────────┼────────────────────────────────────┐
│  Tarbox Core      │                                     │
│  ┌────────────────▼──────────────────────────┐         │
│  │          VFS Layer                        │         │
│  │  - Inode管理  - 路径解析  - 权限检查     │         │
│  └────────────────┬──────────────────────────┘         │
│  ┌────────────────▼──────────────────────────┐         │
│  │          横向功能层                        │         │
│  │  ┌────────┐  ┌────────┐  ┌──────────┐    │         │
│  │  │ 审计层 │  │ 缓存层 │  │ 分层管理 │    │         │
│  │  └────────┘  └────────┘  └──────────┘    │         │
│  └────────────────┬──────────────────────────┘         │
│  ┌────────────────▼──────────────────────────┐         │
│  │          存储抽象层                        │         │
│  │  - 元数据操作  - 数据块操作  - 事务管理  │         │
│  └────────────────┬──────────────────────────┘         │
└───────────────────┼────────────────────────────────────┘
                    │
┌───────────────────▼────────────────────────────────────┐
│              PostgreSQL                                 │
│  ┌──────────┐  ┌───────────┐  ┌──────────┐           │
│  │ 元数据表 │  │  数据块表 │  │ 审计日志 │           │
│  └──────────┘  └───────────┘  └──────────┘           │
└────────────────────────────────────────────────────────┘
```

### 核心组件

#### 1. FUSE 接口层
- 实现标准 POSIX 文件系统接口
- 处理系统调用（open, read, write, mkdir等）
- 将文件系统操作转换为内部 API 调用

#### 2. VFS 层（虚拟文件系统）
- Inode 管理：文件/目录的抽象表示
- 路径解析：将路径转换为 inode
- 权限检查：实现 POSIX 权限模型
- 目录树维护：管理文件系统层次结构

#### 3. 审计层
- 记录所有文件操作
- 支持访问追踪和行为分析
- 提供审计查询接口

#### 4. 缓存层
- 元数据缓存：加速 inode 查询
- 数据块缓存：减少数据库访问
- 路径缓存：加速路径解析
- 采用 LRU 等淘汰策略

#### 5. 分层文件系统
- 写时复制（COW）：层间数据共享
- 层管理：创建、切换、回退检查点
- 线性历史：单向链表结构
- 文件系统钩子：通过虚拟文件控制层操作

#### 6. 原生挂载层
- 将特定目录挂载到宿主机原生文件系统
- 支持只读/读写模式
- 支持跨租户共享或租户独立
- 适用于系统目录（/bin, /usr）和高性能场景（.venv, node_modules）

#### 7. 存储抽象层
- 提供统一的数据库访问接口
- 管理连接池
- 处理事务和并发控制
- 优化批量操作

## 数据模型

### Inode 模型

Inode 是文件系统的核心概念，每个文件或目录对应一个 inode：

```
Inode
├── id: 唯一标识符
├── type: 类型（文件/目录/符号链接）
├── metadata: POSIX 元数据
│   ├── mode: 权限
│   ├── uid/gid: 所有者
│   ├── size: 大小
│   └── timestamps: 时间戳
├── parent: 父目录 inode
├── name: 文件名
└── storage: 存储信息
    └── blocks: 数据块列表
```

### 数据块模型

文件数据被分割成固定大小的块：

```
Block
├── id: 块标识符
├── inode_id: 所属文件
├── index: 块索引
├── size: 实际大小
├── data: 数据内容
└── checksum: 校验和
```

### 目录模型

目录是特殊的 inode，包含子项列表：

```
Directory Inode
├── 基本 inode 属性
└── entries: 目录项列表
    └── [name -> inode_id] 映射
```

## 关键技术决策

### 1. 为什么选择 PostgreSQL？

- **成熟稳定**：久经考验的企业级数据库
- **ACID 支持**：保证数据一致性
- **丰富特性**：支持分区、索引、JSONB等高级特性
- **生态完善**：工具链丰富，运维成熟
- **扩展性**：支持复制、分片等扩展方案

### 2. 为什么使用 FUSE？

- **无需内核模块**：用户态实现，易于开发和部署
- **跨平台**：支持 Linux、macOS、BSD
- **POSIX 兼容**：应用无需修改即可使用
- **灵活性**：便于实现自定义功能

### 3. 数据块大小选择

默认 4KB，理由：

- **平衡性能**：4KB 是大多数场景的最优选择
- **对齐页面**：与操作系统页面大小一致
- **减少碎片**：较小的块减少空间浪费
- **可配置**：支持根据场景调整

### 4. 分层文件系统

线性历史模型（类似 Git）：

- **单向链表**：base -> layer1 -> layer2 -> layer3
- **写时复制**：每层记录相对于父层的变化
- **版本控制**：支持创建检查点和回退
- **简单清晰**：易于理解和管理

### 5. 混合存储策略

结合 PostgreSQL 存储和原生文件系统：

- **PostgreSQL 存储**：用于需要版本控制、审计、分层的文件
- **原生挂载**：用于高性能场景（.venv, node_modules）和系统目录（/bin, /usr）
- **自动路径匹配**：根据配置智能路由到不同存储后端
- **透明切换**：对应用完全透明，保持 POSIX 语义
- **共享机制**：原生挂载支持跨租户共享（只读）或租户独立（读写）

## 性能考虑

### 预期性能指标

- **小文件读写**：100k+ IOPS
- **大文件吞吐**：1GB/s+
- **元数据操作**：50k+ ops/s
- **延迟**：< 1ms（缓存命中）

### 优化策略

1. **多级缓存**：减少数据库访问
2. **批量操作**：合并多个请求
3. **异步处理**：后台执行非关键操作
4. **连接池**：复用数据库连接
5. **预读**：预测性数据加载
6. **写合并**：合并小写入
7. **原生挂载**：高频访问目录绕过数据库，直接访问原生文件系统

## 可扩展性

### 水平扩展

- **读扩展**：通过 PostgreSQL 只读副本
- **写扩展**：通过分片（按命名空间）
- **缓存扩展**：分布式缓存层

### 垂直扩展

- **数据库优化**：调整 PostgreSQL 配置
- **硬件升级**：更快的存储和 CPU

## 安全性

### 访问控制

- **POSIX 权限**：标准的用户/组/其他权限模型
- **命名空间隔离**：多租户隔离
- **审计日志**：所有操作可追溯

### 数据保护

- **校验和**：检测数据损坏
- **版本控制**：防止误删除
- **备份恢复**：定期备份和时间点恢复

## 可运维性

### 监控指标

- **性能指标**：IOPS、吞吐量、延迟
- **容量指标**：存储使用率、增长趋势
- **健康指标**：错误率、可用性

### 运维工具

- **CLI 工具**：命令行管理
- **Web 控制台**：图形化界面
- **Prometheus 集成**：指标导出
- **日志集成**：结构化日志输出

## 未来演进

### 短期目标

- 实现核心文件系统功能
- 完成 FUSE 接口
- 实现基础审计
- 实现简单分层

### 中期目标

- Kubernetes CSI 驱动
- 快照和备份
- 性能优化
- 多租户支持
